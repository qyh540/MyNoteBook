# 操作系统复习

## 第二章

### 进程同步

- 2种形式的制约关系
    - 间接相互制约
    - 直接相互制约

- 临界资源需要互斥访问.

- 进程访问临界资源的代码称为临界区.

- 同步机制规则:

    - 空闲让进
        - 并发过程中某个进程不在临界区时，不阻止其它进程进入临界区
    - 忙则等待.
        - 并发进程中，若干个进程申请进入临界区时，只允许一个进程进入。当已有进程进入临界区时，其它申请进入临界区的进程必须等待，以保证对临界资源的互斥访问。
    - 有限等待.
        - 访问临界资源的进程应保证在有限的时间内进入自己的临界区，避免因长时间申请临界资源得不到满足，而一直等待下去，陷入“等死”状态。
    - 让权等待.
        - 当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。

- 利用信号量机制实现进程同步

    - 整型信号量
        - 定义一个表示资源数目的整型量S,与一般量不同,除初始化外,仅能通过2个标准原子操作wait(S)和signal(S)来访问.通常称这2个操作为P,V操作.

    - 记录型信号量
        - 在整型信号量机制中的wait()操作,只要是信号量S<=0,就会不断测试,不满足让权等待原则

## 第三章

### 处理机调度

- CPU利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)
    - 周转时间:作业完成时间-作业提交时间=作业等待时间+作业运行时间

    - 带权周转时间:W=T/T~s~(T为周转时间,T~s~为运行时间)

    - 等待时间:周转时间-运行时间

    - FCFS(先来先服务):

        - **算法思想**

            主要从“公平”的角度考虑（类似于排队）

            **算法规则**

            按照作业/进程到达的先后顺序进行服务

            **用于调度**
    
        1. 对于作业来说：考虑哪个作业先到达后备队列
            2. 对于进程来说：考虑哪个进程先到达就绪队列

            **是否可抢占**：非抢占式的算法

            **优缺点**
    
        1. 优点：公平、算法实现简单
            2. 缺点：排在长作业（进程）后面的段作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好

            **是否会导致饥饿**：不会

    - SPF/SJF(短作业/进程优先):

        - **算法思想**

            追求最少平均等待时间，最少的平均周转时间、最少平均带权周转时间

            **算法规则**

            最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）

            **用于调度**

            可用于进程调度也可以用于作业调度，用于进程调度时称为“短进程优先算法（SPF）”

            **是否可抢占？**

            SJF和SPF是非抢占式的算法。但是也有抢占式版本–最短剩余时间优先算法（SRTN）

            **优缺点**
    
        1. 优点：“最短的”平均等待时间、平均周转时间
            2. 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先

            **是否会导致饥饿**

            会。如果源源不断地有短作业/进程到来，可能会使长作业/进程长时间得不到服务，产生“饥饿”现象。一直得不到，则称“饿死”

    - 优先级调度算法PSA:

        - **算法思想**

            随着计算机发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序

            **算法规则**

            每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程

            **用于调度**

            即可用于作业也可用于进程

            **是否可抢占？**
    
            （1）非抢占式优先权调度算法 
            ​    把CPU分配给优先权最高的进程后，运行直至完成或发生某事件而阻塞时，才将CPU分配给其他进程。 
           （2）抢占式优先权调度算法 
            ​    在执行期间出现了优先权更高的进程，系统将暂停当前进程，并将CPU分配给新到的优先权最高的进程。

            **优缺点**
    
        1. 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对个作业/进程的偏好程度
        2. 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿

            **是否会导致饥饿**：会

    - 高响应比优先调度算法HRRN:
    
    - 思想：优先级随着等待时间的增加而提高。 
                优先级的变化规律为：![image-20210104091232583](C:\Users\王林清\AppData\Roaming\Typora\typora-user-images\image-20210104091232583.png)

            优点：照顾短作业（进程）；考虑到达次序；兼顾长作业（ 进程） 
    
    - 时间片轮转调度算法RR
    
        - **算法思想**
    
            公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
    
            **算法规则**
    
            按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）
    
            **用于调度**
    
            用于进程调度（因为只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
    
            **是否可抢占？**
    
            若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此属于抢占式算法。
    
            **优缺点**
    
            1. 优点：公平；相应快，适用于分时操作系统
            2. 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度
    
            **是否会导致饥饿**：不会
    
    - 多级反馈队列调度算法
    
        - **算法思想**
    
            对其他调度算法的折中权衡
    
            **算法规则**
    
            1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
            2. 新进程到达时先进入第1级队列放入第一队列的末尾，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级队列，则重新放回该队列队尾
            3. 只有第k级队列为空时，才会为k+1级对头的进程分配时间片
            4. 被抢占处理机的进程重新放回原队列队尾
    
            **用于调度**
    
            用于进程调度
    
            **是否可抢占？**
    
            抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原理运行的进程放回k级队列队尾。（也就是算法规则的第4条）
    
            **优缺点**
    
            优点：对各类型进程相对公平（FCFS优点）；每个新到达的进程都可以很快得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间；可灵活地调整对各类进程的偏好程度。
    
            **是否会导致饥饿**：会
    
- 实时调度算法

    - 可以按不同方式对实时调度算法加以分类：① 根据实时任务性质，可将实时调度的算法分为硬实时调度算法和软实时调度算法；② 按调度方式，则可分为非抢占调度算法和抢占调度算法。 

    - 最早截止时间优先EDF:
        - 思想：根据任务的开始截止时间来确定任务的优先级，即任务的开始截止时间越早，其优先级越高。
    - 最低松弛度优先LLF
        - 该算法在确定任务的优先级时，根据的是任务的紧急(或松弛)程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。 
             　该算法主要用于可抢占调度方式中。假如在一个实时系统中有两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。

- 银行家算法：

    - 1）可利用资源向量Available
        是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available［j］=K，则表示系统中现有Rj类资源K个。
        2）最大需求矩阵Max
        这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max［i,j］=K，则表示进程i需要Rj类资源的最大数目为K。
        3）分配矩阵Allocation
        这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation［i,j］=K，则表示进程i当前已分得Rj类资源的数目为K。
        4）需求矩阵Need。
        这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need［i,j］=K，则表示进程i还需要Rj类资源K个，方能完成其任务。
        Need［i,j］=Max［i,j］-Allocation［i,j］
    - 设Requesti是进程Pi的请求向量，如果Requesti［j］=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：
        (1)如果Requesti［j］≤Need［i,j］，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布最大值。
        (2)如果Requesti［j］≤Available［j］，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。
        (3)系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：
        Available［j］=Available［j］-Requesti［j］;
        Allocation［i,j］=Allocation［i,j］+Requesti［j］;
        Need［i,j］=Need［i,j］-Requesti［j］;
        系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。

- 系统安全性算法：

    - (1) 设置两个向量：① 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work = Available；② Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i] = false；当有足够资源分配给进程时，再令Finish[i] = true。

        (2) 从进程集合中找到一个能满足下述条件的进程： 
         　① Finish[i]=false;
         　② Need[i, j]≤Work[j];
         　若找到，执行步骤(3)，否则，执行步骤(4)。
        (3) 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：
         　Work[j] = Work[j]+Allocation[i, j];
         　Finish[i] =true;
         　go to step 2;
        (4) 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态![image-20210104154654282](C:\Users\王林清\AppData\Roaming\Typora\typora-user-images\image-20210104154654282.png)

- ![image-20210104154743718](C:\Users\王林清\AppData\Roaming\Typora\typora-user-images\image-20210104154743718.png)

- 页面置换算法

    - 最佳置换算法(OPT)

        最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。

    - 先进先出(FIFO)页面置换算法

        优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。

    - 最近最久未使用(LRU)置换算法

        选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。

    - 时钟(CLOCK)置换算法

        LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。

        简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。

- 磁盘调度算法

    - 按请求访问者的先后顺序
        ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200503121948517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU3MTI3MA==,size_16,color_FFFFFF,t_70)优点：这个策略是公平的，每个请求都会得到处理
        缺点：该算法本身出发点未考虑寻道优化，性能接近于随机调度，因此性能很差。

    - #### 最短寻找时间调度算法（SSTF）

        选择寻找**时间最短的访问**者调度
        策略：选择使磁头臂从当前位置开始移动距离最短的IO访问者，即最短寻道时间的请求者，
        问题：每次选择距离最短者同时，忽略了可能由于不断的有新的IO请求进程加入队列中，且与当前磁头位置较近，会使得原请求队列中的距离远的访问者总得不到调度，产生"饥饿现象"。
        ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200503122800889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU3MTI3MA==,size_16,color_FFFFFF,t_70)

    - 从移动臂当前位置开始沿着臂的移动方向去选择离当前移动臂最近的那个柱面的访问者

        ```powershell
        磁道编号是从外到里的，即由内到外磁道号越来越小。
        从当前所在磁道号，从外向里运动，再从里向外运动，或反之。这样就避免了饥饿现象，由于这种移臂调度规律颇似电梯的运动，因而称为电梯算法。
        ```

        ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200503123649147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU3MTI3MA==,size_16,color_FFFFFF,t_70)

    - #### 循环扫描算法（CSCAN）

        ​	为了减少这种延迟，规定磁头单向读 为了减少这种延迟，规定磁头单向读/写运动 写运动 (如只能由内向外)，完成读写后 ，立即返到最小/大磁道号的位置 (构成循环 )，再进行扫描。即 CSCAN算法。
        ​    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200503123847225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU3MTI3MA==,size_16,color_FFFFFF,t_70)