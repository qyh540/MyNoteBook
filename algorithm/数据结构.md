# 数据结构期末复习

## 一	基本概念

- 数据是客观事物的符号表示.

- 数据元素是数据的基本单位.

- 数据项是数据元素的最小单位.

- 数据对象是性质相同的数据元素的集合,是数据的子集.

- 数据结构:相互之间存在一种或多种特定关系的数据元素的集合.

     分为2个层次

    - 逻辑结构:2个要素.
        - 数据元素.
        - 关系:4种基本结构
            - 集合结构:数据元素除了属于同一集合外无其他关系.
            - 线性结构:数据元素间存在一对一的关系.
            - 树结构:数据元素间存在一对多的关系.
            - 图结构:数据元素间存在多对多的关系.
            - ![1](https://myimageshack.oss-cn-hangzhou.aliyuncs.com/img/IMG_20210108_094850_edit_52583409701871.jpg)
    - 存储结构:也称物理结构,计算机中存在2种基本的存储结构.
        - 顺序存储结构.
        - 链式存储结构.

- 算法的五个重要特性:

    - 有穷性.
    - 确定性.
    - 可行性.
    - 输入.
    - 输出.

- 评价算法优劣的标准:

    - 健壮性.
    - 正确性.
    - 可读性.
    - 高效性.
    - 可修改可扩展性.

- 算法的时间复杂度

    - 不考虑计算机的软硬件等环境因素,影响算法时间代价的主要因素是问题规模(算法求解问题输入量的多少).
    - 语句频度:一条语句重复执行的次数.
    - 算法的时间复杂度取决于问题的规模和待处理数据的初态.

## 二	线性表

- 由n(n>=0)个数据特性相同的元素构成的有限序列称为线性表,n为线性表的长度当n=0时线性表为空表.

- 对于非空线性表或线性结构有以下特点:

    - 存在唯一一个被称作"第一个"的数据元素.
    - 存在唯一一个被称作"最后一个"的数据元素.
    - 除第一个外,结构中的每个数据元素均只有一个前驱.
    - 除最后一个外,结构中每个数据元素均只有一个后继.

- 顺序表:

    - LOC(a~i~)=LOC(a~1~)+(i-1)*l (a~i~为第i个元素,l为每个元素占多少个存储单元)
- 顺序表取值:时间复杂度O(1)
  
    - 顺序表查找:时间复杂度O(n) 平均查找长度: $ASL=\sum_{i=1}^{n}{c_i}{p_i}$      ${p_i}=1/n$  $ASL=(n+1)/2$
- 顺序表插入:时间复杂度O(n) E~ins~=n/2.
  
- 顺序表删除:时间复杂度O(n) E~del~=(n-1)/2.
  
- 单链表:

    - 单链表取值:时间复杂度O(n) E~get~=(n-1)/2.
    - 查找:同上.
    - 插入:同上.
      
        - 步骤:(p:待插入节点的前一个节点,s待插入节点)①:s->next=p->next  ②:p->next=s(顺序不能变)
    - 删除:同上.
      
        - 步骤:(p:待删除节点的前驱) ①q=p->next ②p->next=q->next ③delete q(一定要定义一个节点保存要删除节点的物理地址否则将找不到要删除的节点如:p->next=p->next->next此时p->next已经不是要删除节点了).
    - 创建:
        - 前插法:①p->next=L->next ② L->next=p (L:头结点)
        - 尾插法:①p->next=NULL② r->next=p ③ r = p(r:队尾指针初始化指向头结点)

    - 单链表代码

        ```c++
        void initList(List* L) {
        	*L = (List)malloc(sizeof(struct LNode));
        	if (*L == NULL) {
        		printf("分配失败!");
        	}
        	else {
        		(*L)->next = NULL;//头节点的指针域为空
        	}
        }
        void listCreateBefore(List L, int n) {
        	List q = L;
        	for (int i = 0; i < n; i++) {
        		List p = (List)malloc(sizeof(struct LNode));
        		if (p == NULL) {
        			printf("分配失败!");
        		}
        		else {
        			//scanf_s("%d", &p->data);
        			p->data = n - i;
        			p->next = L->next;
        			//第一个新节点的指针域是空指针,其余的是指向前一个节点的指针
        			L->next = p;
        			q = p;
        		}
        	}
        }
        void listCreateBehind(List L, int n) {
        	List end = L;//尾指针
        	for (int i = 0; i < n; i++) {
        		List p = (List)malloc(sizeof(struct LNode));
        		if (p == NULL) {
        			printf("分配失败!");
        		}
        		else {
        			//scanf_s("%d", &p->data);
        			p->data = i + 1;
        			end->next = p;//旧节点指针域指针指向新节点
        			end = p;
        		}
        		end->next = NULL;
        	}
        }
        int getElem(List L, int i) {
        	List p = L->next;//创建指针p指向首元节点
        	int j = 1;//计数器初始化为1
        	while (p && j < i) {
        		p = p->next;
        		++j;
        	}
        	if (!p || j > i) {
        		return -1;
        	}
        	return p->data;
        }
        int listLength(List L) {
        	List p;
        	p = L->next;
        	int j = 0;
        	while (p) {
        		p = p->next;
        		j++;
        	}
        	return j;
        }
        List findKth(List L, int k) {
        	List p = L->next;
        	int i = 1;
        	while (p != NULL && i < k) {
        		p = p->next;
        		i++;
        	}
        	if (i == k) {
        		return p;
        	}
        	else {
        		return NULL;
        	}
        }
        List findValue(List L, int e) {
        	List p = L->next;
        	while (p && p->data != e) {
        		p = p->next;
        	}
        	return p;
        }
        void listInsert(List L, int i, int e) {
        	List p = L;
        	int j = 0;
        	while (p && (j < i - 1)) {
        		p = p->next;
        		j++;
        	}
        	if (!p || j > i - 1) {
        		return;
        	}
        	List s = (List)malloc(sizeof(struct LNode));
        	if (s == NULL) {
        		printf("分配失败!");
        	}
        	else {
        		s->data = e;
        		s->next = p->next;
        		p->next = s;
        	}
        }
        void listDelete(List L, int i) {
        	List p = L;
        	int j = 0;
        	while (p->next && (j < i - 1)) {
        		p = p->next;
        		j++;
        	}
        	if (!p->next || j > i - 1) {
        		return;
        	}
        	List q = p->next;
        	p->next = q->next;
        	free(q);
        }
        void listMerge(List aL, List bL) {
        	int m = listLength(aL);
        	int n = listLength(bL);
        	for (int i = 1; i <= n; i++) {
        		int e = getElem(bL, i);
        		if (findValue(aL, e) == NULL) {
        			listInsert(aL, ++m, e);
        		}
        	}
        }
        void printList(List L) {
        	List p = L->next;
        	while (p) {
        		printf("%d ", p->data);
        		p = p->next;
        	}
        	printf("\n");
        }
        List getListMax(List L) {
        	List p = L->next;
        	List maxNode = p;
        	while (p) {
        		if (p->data > maxNode->data) {
        			maxNode = p;
        		}
        		p = p->next;
        	}
        	return maxNode;
        }
        void delete(List* L, int mink, int maxk) {
        	List p = (*L)->next;
        	List pre = p;
        	while (p && p->data <= mink)
        	{//查找第一个值>mink的结点
        		pre = p;
        		p = p->next;
        	}
        	if (p)
        	{
        		while (p && p->data < maxk)
        		{		// 查找第一个值 ≥maxk的结点
        			p = p->next;
        		}
        		List q = pre->next;
        		pre->next = p;  // 修改指针
        		while (q != p)
        		{// 释放结点空间
        			List s = q->next;
        			free(q);
        			q = s;
        		}
        	}
        }
        ```

- 循环链表:

    - 表中最后一个节点指针域指针指向表头.

- 双向链表:

    - 有2个指针域.
    - 插入:①s->prior = p->prior②p->prior=s ③s->next=p ④s->prior->next=s(①必须在②前面)
    - 删除:①p->prior->next=p->next ②p->next->prior=p->prior ③ delete p

- 顺序表和链表比较:

    - 存储密度=数据元素本身占用存储量/节点结构占用的存储量
        - 存储密度越大空间利用率越大,顺序表存储密度=1,链表存储密度<1;
    - 顺序表存储空间需要预先分配,元素个数扩充受一定限制,易造成存储空间浪费,插入和删除操作需要移位效率低但存储密度高,用数组存储可以进行随机存取所以存取效率高.
    - 链表不需要预先分配内存,更加灵活,插入和删除效率高.


## 三	栈和队列

- 栈:表尾端称为栈顶,表头端称为栈底,遵循先进后出原则.

    - 若输入序列   …,Pj…Pk…Pi …(Pj<Pk<Pi)，
        一定不存在这样的输出序列  …,Pi…Pj…Pk …

    - 顺序栈

        ```c++
        #include<bits/stdc++.h>
        #define MaxSize 100
        typedef struct SNode* Stack;
        struct SNode {
        	int* data;
        	int top;
        };
        void initS(Stack& S) {
        	S->data = new int[MaxSize];
        	S->top = -1;
        }
        void push(Stack ptrS, int item) {  //入栈
        	if (ptrS->top == MaxSize - 1) {
        		printf("栈已满!");
        		return;
        	}
        	else {
        		ptrS->data[++(ptrS->top)] = item;
        	}
        }
        int pop(Stack ptrS) {  //出栈
        	if (ptrS->top == -1) {
        		printf("堆栈空!");
        	}
        	else {
        		return ptrS->data[(ptrS->top)--];
        	}
        }
        int getTop(Stack ptrS) {  // 取栈顶元素
        	if (ptrS->top == -1) {
        		printf("堆栈空!");
        	}
        	else {
        		return ptrS->data[ptrS->top];
        	}
        }
        ```

    - 链栈

        ```c++
        #include<bits/stdc++.h>
        using namespace std;
        
        typedef struct SNode {
        	int data;
        	Stack next;
        }SNode, * Stack;
        
        void initS(Stack& S) {  //初始化
        	S = new SNode;  // 头结点
        	S->next = NULL;
        }
        void push(Stack& S, int e) {
        	Stack p = new SNode;
        	p->data = e;
        	p->next = S->next;
        	S->next = p;
        }
        int pop(Stack& S) {
        	if (S->next == NULL) {
        		cout << "栈空" << endl;
        		return 0;
        	}
        	Stack p = S->next;
        	int e = p->data;
        	S->next = p->next;
        	delete p;
        	return e;
        }
        int getTop(Stack S) {
        	if (S->next == NULL) {
        		cout << "栈空" << endl;
        		return 0;
        	}
        	int e = S->next->data;
        	return e;
        }
        ```

        

- 队列:允许插入的一端叫队尾,允许删除的一端叫队头,遵循先进先出原则(尾进头出).

    - 顺序队列

        - 队列长度:$len=(N+rear-front)\%N$ N:队列最大容量 

        ```c++
        #include<iostream>
        #define MAX_SIZE 100
        using namespace std;
        
        typedef struct QNode* Queue;
        struct QNode {
        	int data[MAX_SIZE];
        	int rear;
        	int front;
        };
        void initQ(Queue& Q) {
        	Q->rear = Q->front = 0;
        }
        void addQ(Queue Q, int item) {
        	if ((Q->rear + 1) % MAX_SIZE == Q->front) {
        		cout << "队列满!\n";
        		return;
        	}
        	else {
        		Q->rear = (Q->rear + 1) % MAX_SIZE;
        		Q->data[Q->rear] = item;
        	}
        }
        int deleteQ(Queue Q) {
        	if (Q->front == Q->rear) {
        		cout << "队列空!\n";
        	}
        	else {
        		Q->front = (Q->front + 1) % MAX_SIZE;
        		return Q->data[Q->front];
        	}
        }
        int lengthQ(Queue Q) {
        	return(MAX_SIZE + Q->rear - Q->front) % MAX_SIZE;
        }
        ```

    - 链队

        ```c++
        /*
        * 链式队列可以用单链表实现,插入和删除分别在链表
        * 的尾部和头部进行.(因为在尾部删除找不到上一个
        * 节点)
        */
        #include<iostream>
        using namespace std;
        
        typedef struct Node {  // 节点
        	int data;  // 数据域
        	List next;  // 指针域
        }Node, * List;
        typedef struct QNode {  // 链队列结构
        	List rear;  // 指向队尾节点
        	List front;  // 指向队头节点
        }QNode, * Queue;
        void initQ(Queue& Q) {
        	Q->front = new Node;
        	Q->front->next = NULL;
        	Q->rear = Q->front;
        }
        int deleteQ(Queue& Q) {
        	if (Q->front->next == NULL) {
        		cout << "队空!\n";
        		return 0;
        	}
        	List p = Q->front->next;
        	int e = p->data;
        	Q->front->next = p->next;
            //如果p是最后一个元素则将对尾指针重置
        	if (Q->rear == p) {
        		Q->rear == Q->front;
        	}
        	delete p;
        	return e;
        }
        void addQ(Queue& Q, int e) {
        	List p = new Node;
        	p->data = e;
        	p->next = Q->rear->next;
        	Q->rear = p;
        }
        int getHead(Queue Q) {
        	if (Q->rear != Q->front) {
        		return Q->front->next->data;
        	}
        	else {
        		cout << "队空!\n";
        		return 0;
        	}
        }
        ```

        

## 四	串,数组和广义表

- 串(字符串):是由零个或多个字符组成的有限序列,一般记为$s="a_1a_2...a_n"(n\geq0)$

    - 串的模式匹配算法

        - BF

            - 最好平均时间复杂度:O(m+n)

            - 最坏平均时间复杂度:O(m*n)

                ```c++
                int indexBF(string s, string t, int index) {
                	if (s.length() && t.length() && s.length() > t.length()) {
                		int i = index;
                		int j = 0;
                		while (i < s.length() && j < t.length()) {
                			if (s[i] == t[j]) {
                				i++;
                				j++;
                			}
                			else {
                				i = i - j + 1;
                				j = 0;
                			}
                		}
                		if (j == t.length()) {
                			return i - t.length();
                		}
                		else {
                			cout << "未查到!" << endl;
                			return -1;
                		}
                	}
                	else {
                		cout << "不合要求!" << endl;
                		return -1;
                	}
                }
                ```

        - KMP

            - 算法平均时间复杂度:O(m+n)

                ```c++
                void getNext(string t, int next[]) {
                	int i = -1, j = 0;
                	next[0] = -1;
                	while (j < t.length() - 1) {
                		if (i == -1 || t[j] == t[i]) {
                			++i;
                			++j;
                			next[j] = i;
                		}
                		else {
                			i = next[i];
                		}
                	}
                }
                int indexKMP(string s, string t) {
                	int i = 0;
                	int j = 0;
                	int slen = s.length();
                	int tlen = t.length();
                	int* next = new int[t.length()];
                	getNext(t, next);
                	while (i < slen && j < tlen) {
                		if (j == -1 || s[i] == t[j]) {
                			i++;
                			j++;
                		}
                		else {
                			j = next[j];
                		}
                	}
                	if (j == tlen) {
                		return i - j;
                	}
                	else {
                		return -1;
                	}
                }
                ```

- 数组:
    - 矩阵的压缩存储
        - 

- 广义表:广义表是线性表的推广,一般记作$LS=(a_1,a_2,a_3...a_n)    n为广义表长度$.
    - 取表头:getHead(LS):取出的表头为非空广义表的第一个元素,它可以是原子也可以是子表.
    - 取表尾:getTail(LS):取出的表尾为出去表头外其余所有元素构成的表.所以表尾必是广义表.

## 五	树和二叉树

- 树:是n个节点的有限集($n\geq0$),它或为空树(n=0)或为非空树,对于非空树有以下特点:
    - 有且仅有一个称之为根的节点;
    - 除根结点外可分为m>0个互不相交的有限集,其中每个集合本身又是一棵树,并且称其为根的子树.

    - 基本术语:
        - 节点:树中的一个独立单元.包含一个数据元素及若干个指向其子树的分支.
        - 节点的度:节点所拥有的子树数称为节点的度.
        - 树的度:树内节点度的最大值.
        - 叶子节点:度为零的节点成为叶子节点或终端节点.
        - 非终端节点:度不为零的节点称为非中端节点或分支节点.除根节点外,非分支节点又称为内部节点.
        - 双亲和孩子:节点的子树称为该节点的孩子,该节点称为孩子的双亲节点.
        - 兄弟:同一双亲的孩子节点互称兄弟节点.
        - 祖先:从根到该节点所经历分支上所有的节点.
        - 子孙:以某个节点为根的子树中任一节点都称为该节点的子孙.
        - 层次:节点的层次从根开始定义起,根为第一层,根的孩子为第二层.树中任一节点的层次为双亲节点的层次加1.
        - 堂兄弟:双亲在同一层的孩子节点互为堂兄弟.
        - 树的深度:树中结点最大的层次称为树的深度或高度.
        - 有序树和无序树:如果将树中节点的各子树看成从左至右是有次序的(既不能互换),则称该树为有序树否则称其为无序树.
        - 森林:是$m(m\geq0)$棵互不相交的树的集合.
    
- 二叉树:有n$(n\geq0)$个节点的树T.

    - 非空树定义:

        - 有且仅有一个根节点.
        - 除根结点外的其余节点分为2个互不相交的子集T~1~和T~2~,分别称为T的左子树和右子树,且T~1~和T~2~本身都是二叉树.
        - 二叉树中不存在度>2的节点.
        - 二叉树是有序树.

    - 性质:

        - 在二叉树的第i层至多有2^i-1^个节点.

        - 深度为k的二叉树至多有2^k^-1个节点.

        - 对于任一一棵二叉树T,如果其终端节点数为n~0~,度为2的节点数为n~2~,则$n_0=n_2+1$.

            > 证:设一棵有着n个节点的二叉树,其终端节点数为n~0~,度为1的节点数为n~1~,度为2的节点数为n~2~,则n=n~0~+n~1~+n~2~.
            >
            > 又一颗树共有分支n-1条,其中度为1的节点每个节点有一条,度为2的节点有2条,则n-1=2n~2~+n~1~.
            >
            > 联立可得$n_0=n_2+1$

- 满二叉树:每一层上的节点数都是最大的.

- 完全二叉树:深度为k,节点数为n的二叉树当且仅当其每一个节点都与深度为k的满二叉树中编号从1至n的节点一一对应时,称之为完全二叉树.

    - 叶子节点只能出现在层次最大的2层.
    - 度为1的节点为1个或0个.
    - 对任一节点若其右分支下的子孙最大层数为l,则其左分支下的子孙最大层数必为l或l+1.

    二叉树代码:

    ```c++
    /*
    * 二叉树的中序后序递归非递归遍历
    */
    #include<iostream>
    #include<stack>
    using namespace std;
    
    // 二叉链表存储二叉树
    typedef struct BTNode {
    	char data;
    	BTNode* left;
    	BTNode* right;
    }BTNode, * BTree;
    // 附加标志域方便实现非递归后序遍历
    typedef struct node {
    	BTree t;
    	bool flag;
    };
    // 先序创建二叉树
    void createBTree(BTree& BT) {
    	char ch;
    	cin >> ch;
    	if (ch == '#') {
    		BT = NULL;
    	}
    	else {
    		BT = new BTNode;
    		BT->data = ch;
    		createBTree(BT->left);
    		createBTree(BT->right);
    	}
    }
    // 递归实现中序遍历
    void inorderTraversal(BTree BT) {
    	if (BT) {
    		// 遍历左子树
    		inorderTraversal(BT->left);
    		// 访问根节点
    		cout << BT->data << " ";
    		// 遍历右子树
    		inorderTraversal(BT->right);
    	}
    }
    // 递归实现后序遍历
    void postTraversal(BTree BT) {
    	if (BT) {
    		// 遍历左子树
    		postTraversal(BT->left);
    		// 遍历右子树
    		postTraversal(BT->right);
    		// 访问根节点
    		cout << BT->data << " ";
    	}
    }
    // 中序遍历的非递归实现
    void inTra(BTree BT) {
    	// 创建堆栈s
    	stack<BTree> s;
    	BTree t = BT;
    	// 如果树不空或堆栈不空
    	while (t || !s.empty()) {
    		// 一直遍历左子树并将节点压入堆栈
    		while (t) {
    			s.push(t);
    			t = t->left;
    		}
    		if (!s.empty()) {
    			// 左子树遍历完成后堆栈不空则从栈顶弹出节点并访问
    			t = s.top();
    			s.pop();
    			cout << t->data << " ";
    			// 以中序遍历右子树
    			t = t->right;
    		}
    	}
    }
    // 后序遍历的非递归实现
    void postTra(BTree BT) {
    	stack<node> s;
    	while (BT || !s.empty()) {
    		// 沿左子树遍历,第一次遇到,标志为false并压入栈
    		while (BT) {
    			node bt;
    			bt.t = BT;
    			bt.flag = false;
    			s.push(bt);
    			BT = BT->left;
    		}
    		// 如果堆栈不空且都是第二次遇到则访问该节点并出栈
    		while (!s.empty() && s.top().flag) {
    			cout << s.top().t->data << " ";
    			s.pop();
    		}
    		// 第二次遇到,标志改为true,接着沿右子树遍历
    		if (!s.empty()) {
    			s.top().flag = true;
    			BT = s.top().t->right;
    		}
    	}
    }
    // 后序清空树
    void clearBTree(BTree& BT) {
    	if (BT) {
    		clearBTree(BT->left);
    		clearBTree(BT->right);
    		delete BT;
    	}
    }
    void SequenceTra(BTree BT) {
    	if (!BT) return;
    	BTree T = BT;
    	queue<BTree> Q;
    	Q.push(T);
    	while (!isEmpty(Q)) {
    		T = deleteQ(Q);
    		cout << T->data;
    		if (T->left)addQ(Q, T->left);
    		if (T->right) addQ(Q, T->right);
    	}
    }
    void printLeaves(BTree Bt) {
    	if (Bt) {
    		if (!Bt->left && !Bt->right) {
    			cout << Bt->data;
    		}
    		printLeaves(Bt->left);
    		printLeaves(Bt->right);
    	}
    }
    int countLeaves(BTree BT) {
    	if (!BT) {
    		return 0;
    	}
    	else if (!BT->left && !BT->right) {
    		return 1;
    	}
    	else {
    		return countLeaves(BT->left) + countLeaves(BT->right);
    	}
    }
    int getHeight(BTree BT) {
    	int rH, lH, maxH;
    	if (BT) {
    		lH = getHeight(BT->left);
    		rH = getHeight(BT->right);
    		maxH = (lH > rH) ? lH : rH;
    		return maxH + 1;
    	}
    	else return 0;
    }
    void copyBT(BTree BT, BTree& newT) {
    	if (!BT) {
    		newT = NULL;
    		return;
    	}
    	else {
    		newT = new BTNode;
    		newT->data = BT->data;
    		copyBT(BT->left, newT->left);
    		copyBT(BT->right, newT->left);
    	}
    }
    int nodeCount(BTree BT) {
    	if (BT == NULL) {
    		return 0;
    	}
    	else {
    		return nodeCount(BT->left) + nodeCount(BT->right) + 1;
    	}
    }
    void longestPath(BTree BT) {
    	BTree i[MAX_SIZE], s[MAX_SIZE], p = BT;
    	int j, tag[MAX_SIZE], top = 0, longest = 0;
    	while (p || top > 0) {
    		while (p) {
    			s[++top] = p;
    			tag[top] = 0;
    			p = p->left;
    		}
    	}
    	if (tag[top] == 1) {
    		if (!s[top]->left && !s[top]->right) {
    			if (top > longest) {
    				for (j = 1; j <= top; j++) {
    					i[j] = s[j];
    				}
    				longest = top;
    				top--;
    			}
    			else if (top > 0) {
    				tag[top] = 1;
    				p = s[top]->right;
    			}
    		}
    	}
    	cout << longest << endl;
    	for (j = 0; j < longest; j++) {
    		cout << i[j]->data << endl;
    	}
    }
    ```

- 线索二叉树:

- 哈夫曼树:又称最优树,是一类带权路径长度最短的树.

    - 只有度为0和2的树.

    - ```c++
        /*哈夫曼树的构造和哈夫曼编码*/
        #include<iostream>
        #define MAX_SIZE 1000
        using namespace std;
        
        //哈夫曼树的存储结构
        typedef struct {
        	//节点的权值
        	int weight;
        	//节点双亲,左右孩子的数组下标
        	int parent, left, right;
        }TNode, * HTree;
        
        //动态数组存储哈夫曼编码
        typedef char** HCode;
        
        //返回2个双亲域为0且权值最小的节点
        void select(HTree HT, int n, int& s1, int& s2) {
        	//找到第一个双亲域为0的节点,并将s1初始化为其下标
        	for (int i = 1; i <= n; i++) {
        		if (!HT[i].parent) {
        			s1 = i;
        			break;
        		}
        	}
        	//从s1+1开始寻找双亲域为0且权值最小的的节点,并将下标赋值给s1
        	for (int i = s1 + 1; i <= n; i++) {
        		if (!HT[i].parent && HT[i].weight < HT[s1].weight) {
        			s1 = i;
        		}
        	}
        	//找到一个双亲域为0的节点且不是s1的节点,并将其下标赋值给s2
        	for (int i = 1; i <= n; i++) {
        		if (i != s1 && !HT[i].parent) {
        			s2 = i;
        		}
        	}
        	//从s2+1开始寻找双亲域为0且不是s1且权值最小的的节点,并将下标赋值给s2
        	for (int i = s2 + 1; i <= n; i++) {
        		if (!HT[i].parent && i != s1 && HT[i].weight < HT[s2].weight) {
        			s2 = i;
        		}
        	}
        }
        //创建哈夫曼树函数
        void createHT(HTree& HT, int n) {
        	if (n <= 1) {
        		return;
        	}
        	int k = 2 * n;
        	HT = new TNode[k];
        	//初始化哈夫曼树节点
        	for (int i = 1; i < k; i++) {
        		HT[i].parent = 0;
        		HT[i].left = 0;
        		HT[i].right = 0;
        	}
        	//输入权值
        	for (int i = 1; i <= n; i++) {
        		cin >> HT[i].weight;
        	}
        	int s1, s2;
        	//通过n-1次的查询,合并构造哈夫曼树
        	for (int i = n + 1; i < k; i++) {
        		//查询:查找2个双亲域为0且权值最小的节点
        		select(HT, i - 1, s1, s2);
        		//合并:将这2节点合并成一棵树
        		HT[s1].parent = i;
        		HT[s2].parent = i;
        		HT[i].left = s1;
        		HT[i].right = s2;
        		//新树节点权值=左右子树权值之和
        		HT[i].weight = HT[s1].weight + HT[s2].weight;
        	}
        }
        //创建哈夫曼编码表函数
        void createHC(HCode& HC, HTree HT, int n) {
        	//动态分配空间给HC,下表为0的空间不用
        	int m = n + 1;
        	HC = new char* [m];
        	//动态分配空间给数组temp,temp用来暂存哈夫曼编码
        	char* temp = new char[n];
        	//加上终止符
        	temp[n - 1] = '\0';
        	for (int i = 1; i <= n; i++) {
        		//初始化start指向temp尾部因为从叶节点开始编码(从尾到头)
        		int start = n - 1;
        		int c = i;
        		//初始化f为c节点的双亲
        		int f = HT[c].parent;
        		while (f) {
        			--start;
        			if (HT[f].left == c) {
        				temp[start] = '0';
        			}
        			else {
        				temp[start] = '1';
        			}
        			c = f;
        			f = HT[f].parent;
        		}
        		m = n - start;
        		//将编码赋给HC[i]
        		HC[i] = new char[m];
        		strcpy(HC[i], &temp[start]);
        	}
        	//释放temp空间
        	delete[] temp;
        }
        //译码函数
        void trancHC(HTree HT, char* binCode, char* tran, char* ch, int n) {
        	//初始化par为哈夫曼树根节点下标
        	int par = 2 * n - 1;
        	//记录tran下标
        	int k = 0;
        	int i = 0;
        	//译码
        	for (i = 0; binCode[i] != '\0'; i++) {
        		//如果是0则par指向左子树否则指向右子树
        		if (binCode[i] == '0') {
        			par = HT[par].left;
        		}
        		else {
        			par = HT[par].right;
        		}
        		//如果par指向了叶节点则将叶节点所表示字符赋给tran数组
        		if (!HT[par].left && !HT[par].right) {
        			tran[k++] = ch[par];
        			par = 2 * n - 1;
        		}
        	}
        	//加上终止符
        	tran[k] = '\0';
        }
        
        ```

    

## 六	图

- 定义:图是有两个集合V,E组成V是有穷非空集合是顶点集,E是有穷集合是边集.

- 术语:

    - 子图:假设又2个图G=(V,E),G^＇^ =(V^＇^,E^＇^)若有Ｖ^＇^属于V,G^＇^属于G,则说G^＇^是G的子图.
    - 无向完全图和有向完全图:对于无向图若有n(n-1)/2条边,则称为无向完全图.对于有向图若有n(n-1)条弧,则称其为有向完全图.(无向图用"边"用(v~1~,v~2~)表示,有向图用"弧"用<v~1~,v~2~>表示)
    - 稀疏图和稠密图:有很少条边或弧,如$e<nlog_2n$(e为边(弧)数,n为顶点点数)则称之为稀疏图,反之称为稠密图.
    - 权和网:图的边可以带权,带权图称为网.
    - 邻接点:对于无向图G,如果有边(v~1~,v~2~)则称顶点v~1~,v~2~互为邻接点,即v~1~,v~2~相邻接.边(v~1~,v~2~)依附于顶点v~1~,v~2~,或者说边(v~1~,v~2~)和顶点v~1~,v~2~相关联.
    - 度,入度和出度:顶点的v的度是指和v相关联的边数,记为TD(v).对于有向图而言,入度是以v为头的弧的数目记为ID(v),出度是以v为尾的弧的数目记为OD(v),TD(v)=ID(v)+OD(v).一般的$$e=\frac{1}{2}\sum_{i=1}^{n}TD(v_i)$$
    - 路径和路径长度:从v~1~到v~2~的路径是一个顶点序列.路径长度是一条路径上经过的边或弧的数目.
    - 回路和环:第一个顶点和最后一个顶点相同的路径叫回路或环.
    - 简单路径,简单回路或简单环:没有重复顶点的路径叫简单路径;除了第一个和最后一个外没有重复顶点的回路或环叫简单回路或简单环.
    - 连通,连通图和连通分量:在无向图G中,如果从v~1~到v~2~有路径则称v~1~,v~2~是连通的;如果对于图中任意2个顶点v~1~,v~2~都是连通的,则称G是连通图;连通分量就是指该图的极大连通子图.
    - 强连通图和强连通分量:在有向图G中,如果每一对v~1~,v~2~之间都存在路径,则称G是强连通图.有向图中的极大强连通子图称为强连通分量.
    - 连通图和生成树:一个极小连通子图,它含有图中全部顶点但只有足以构成一棵树的n-1条边,这样的连通子图称为连通图的生成树.如果在一棵树上添加一条边则它必定变成环.
    - 有向树和生成森林:有一个顶点的入度为0,其他顶点的入度为1的有向图称为有向树.由若干棵有向树组成的森林叫生成森林.

- 图的存储方式:

    - 邻接矩阵:

        - 时间复杂度O(v^2^)
        - 适合表示稠密图

    - 邻接表:

        - 时间复杂度O(v+e)
        - 适合稀疏图

    - 代码:

        ~~~c++
        /*图的邻接矩阵和邻接表表示*/
        #include<iostream>
        #define MAX_INT 32767
        #define MAX_SIZE 100
        using namespace std;
        
        //邻接矩阵
        typedef struct {
        	//顶点域
        	char vertex[MAX_SIZE];
        	//邻接矩阵
        	int adjM[MAX_SIZE][MAX_SIZE];
        	//顶点数量
        	int verNum;
        	//边数量
        	int edgNum;
        }AMGraph;
        
        // 边节点
        typedef struct ENode {
        	//顶点下标
        	int adjvex;
        	//指针域
        	ENode* nextEdg;
        	// int weight;
        }ENode;
        
        //头结点
        typedef struct {
        	//顶点
        	char data;
        	//头指针
        	ENode* firstN;
        }VNode, AList[MAX_SIZE];
        
        //邻接表
        typedef struct {
        	AList verMessage;
        	//顶点数
        	int verNum;
        	//边数
        	int edgNum;
        }ALGraph;
        
        //邻接矩阵寻找下标
        int findIndex(AMGraph G, char v) {
        	int i = 0;
        	//遍历顶点数组
        	for (; i < G.verNum; i++) {
        		if (v == G.vertex[i]) {
        			return i;
        		}
        	}
        	if (i >= G.verNum) {
        		cout << "未找到顶点!" << endl;
        		return -1;
        	}
        }
        
        //邻接表寻找下标
        int findIndex(ALGraph G, char v) {
        	int i = 0;
        	for (; i < G.verNum; i++) {
        		if (v == G.verMessage[i].data) {
        			return i;
        		}
        	}
        	if (i >= G.verNum) {
        		cout << "未找到顶点!" << endl;
        		return -1;
        	}
        }
        
        //创建邻接矩阵
        bool createAMG(AMGraph& G) {
        	//初始化
        	cout << "请输入表的顶点数和边数:";
        	cin >> G.verNum >> G.edgNum;
        	cout << "请输入表的顶点名称:";
        	for (int i = 0; i < G.verNum; i++) {
        		cin >> G.vertex[i];
        	}
        	for (int i = 0; i < G.verNum; i++) {
        		for (int j = 0; j < G.verNum; j++) {
        			G.adjM[i][j] = MAX_INT;
        		}
        	}
        	//连接顶点
        	cout << "请输入边依附的顶点及权值:" << endl;
        	for (int k = 0; k < G.edgNum; k++) {
        		char v1, v2;
        		int weight;
        		cin >> v1 >> v2 >> weight;
        		int i = findIndex(G, v1);
        		int j = findIndex(G, v2);
        		if (i == -1 || j == -1) {
        			return false;
        		}
        		G.adjM[i][j] = weight;
        		G.adjM[j][i] = weight;
        	}
        	return true;
        }
        
        //创建邻接表
        bool createALG(ALGraph& G) {
        	cout << "请输入表的顶点数和边数:";
        	cin >> G.verNum >> G.edgNum;
        	cout << "请输入顶点名:";
        	for (int i = 0; i < G.verNum; i++) {
        		cin >> G.verMessage[i].data;
        		G.verMessage[i].firstN = NULL;
        	}
        	cout << "请输入边依附的顶点:" << endl;
        	for (int k = 0; k < G.edgNum; k++) {
        		char v1, v2;
        		int i, j;
        		cin >> v1 >> v2;
        		i = findIndex(G, v1);
        		j = findIndex(G, v2);
        		if (i == -1 || j == -1) {
        			return false;
        		}
        		//头插法
        		ENode* p1 = new ENode;
        		ENode* p2 = new ENode;
        		if (!p1 || !p2) {
        			cout << "内存分配失败!" << endl;
        			return false;
        		}
        		p1->adjvex = j;
        		p1->nextEdg = G.verMessage[i].firstN;
        		G.verMessage[i].firstN = p1;
        		p2->adjvex = i;
        		p2->nextEdg = G.verMessage[j].firstN;
        		G.verMessage[j].firstN = p2;
        	}
        	return true;
        }
        ~~~

- 图的遍历:

    - 深度优先搜索(DFS):类似于树的先序遍历.

    - 广度优先索搜(BFS):类似于树的层次遍历.

    - 时间复杂度:O(v+e);

    - 代码

        ```c++
        //深度优先搜索
        void dfsAMG(AMGraph G, int v) {
        	cout << G.vertex[v];
        	visited[v] = true;
        	for (int i = 0; i < G.verNum; i++) {
        		if ((G.adjM[v][i] != MAX_INT) && (!visited[i])) {
        			dfsAMG(G, i);
        		}
        	}
        }
        
        //广度优先搜索
        void bfsAMG(AMGraph G, int v) {
        	cout << G.vertex[v];
        	visited[v] = true;
        	queue<int> Q;
        	Q.push(v);
        	while (!Q.empty()) {
        		int u = Q.front();
        		Q.pop();
        		for (int i = 0; i < G.verNum; i++) {
        			if ((G.adjM[u][i] != MAX_INT) && (!visited[i])) {
        				cout << G.vertex[i];
        				visited[i] = true;
        				Q.push(i);
        			}
        		}
        	}
        }
        ```

- 最小生成树:在一个连通网的所有生成树中,各边权值最小的那棵树称为最小代价生成树,简称最小生成树.

    - MST性质:假设N=(V,E)是一个连通网,U是顶点集V的一个非空子集.若(u,v)是一条具有最小权值的边,其中$u\in U,v\in V-U$,则必存在一颗包含边(u,v)的最小生成树.

    - Prim算法(加点法):

        - 时间复杂度:O(v^2^).
        - 适合稠密图.

    - Kruskal算法:

        - 时间复杂度:O(elog~2~e).
        - 适合稀疏图.

    - 代码:

        ```c++
        
        ```

- 最短路径:在带权有向网中,习惯称路径上的第一个顶点为源点(Source)最后一个顶点为终点(Destination).

    - Dijkstra单源最短路径算法:

        - 时间复杂度:O(v^2^).

    - Floyd多源最短路径算法:

        - 时间复杂度:O(V^3^).

    - 代码:

        ```c++
        
        ```

- 拓扑排序

    - AOV-网:
        - 一个无环的有向图称为有向无环图(DAG).
        - 用顶点表示活动,用弧表示活动间的的优先关系的有向图称为用顶点表示活动的网,简称AOV-网.
    - 拓扑排序就是将AOV-网中所有顶点排成一个线性序列,该序列满足:若在AOV-网中由顶点v~i~到v~j~由一条路径,则在该线性序列中v~i~必在v~j~前面.
    - 过程:
        - 1):在有向图中选一个无前驱的顶点且输出它.
        - 2):删除该顶点及所有以它为尾的弧.
        - 3):重复1)和2),直至图中不存在顶点.

    - 算法实现:

        ```c++
        
        ```

- 关键路径

    - AOE-网:以边表示活动的网(带权有向无环图),其中顶点表示事件,弧表示活动,权表示活动持续的时间.通常AOE-网可以用来估算工程完成的时间.
    - 网中只有一个入度为0的点,称作源点;只有一个出度为0的点,称作汇点.一条路径上各弧的权值之和称为该路径的带权路径长度(路径长度).
    - 关键路径就是一条从源点到汇点路径长度最长的路径,路径上的活动叫<u>关键活动</u>.

## 七	查找

- 基本概念:

    - 查找表:同一类型的数据元素(或记录)构成的集合.
    - 关键字:数据元素(或记录)中某个数据项的值,用来标识一个数据元素(或记录).若此关键字可以唯一的标识一个记录,则称此关键字为主关键字,否则为次关键字.
    - 查找:根据给定的某个值,在查找表中确定一个其关键等于给定值的记录或数据元素.
    - 动态查找表和静态查找表:若在查找的同时对表做修改操作(如插入和删除),则相应的表称之为动态查找表.否则为静态查找表.
    - 平均查找长度:$WSL=\sum_{i=1}^{n}{c_i}{p_i}$

- 线性表的查找:

    - 顺序查找:遍历整个表.

        - 时间复杂度:O(n).
        - 平均查找长度:WSL=(n+1)/2
        - 代码:

        ```c++
        //设置监视哨的顺序查找
        int searchSeq(SSTable SST, int key) {
        	SST.key[0] = key;
        	int i;
        	for (i = SST.length; SST.key[i] != key; i--);
        	return i;
        }
        ```

- 折半查找(二分查找):

    - 要求线性表必须要采用顺序存储结构,而且表中元素按关键字有序排列.

    - 时间复杂度:O(log~2~n)

    - 平均查找长度:$ASL=\frac{n+1}{n}log_2(n+1)-1$

    - 代码:

        ```c++
        //递归查找
        int searchBin(SSTable SST, int key, int low, int high) {
        	int mid = (low + high) / 2;
        	if (key == SST.key[mid]) {
        		return mid;
        	}
        	else if (key < SST.key[mid]) {
        		searchBin(SST, key, low, mid - 1);
        	}
        	else {
        		searchBin(SST, key, mid + 1, high);
        	}
        	if (low > high) {
        		return -1;
        	}
        }
        //非递归查找
        int searchBin(SSTable SST, int key) {
        	int high = SST.length - 1;
        	int low = 0;
        	while (low <= high) {
        		int mid = (high + low) / 2;
        		if (key == SST.key[mid]) {
        			return mid;
        		}
        		else if (key < SST.key[mid]) {
        			high = mid - 1;
        		}
        		else {
        			low = mid + 1;
        		}
        	}
        	return -1;
        }
        ```

    - 分块查找:又称索引顺序查找,除表本身外尚需建立一个索引表,对每一个子表或称块建立一个索引项其中包括2项内容:关键字(其值为该子表内的最大关键字)和指针项(指示该子表的第一个记录在表中位置).

        - $WSL=log_2(\frac ns+1)+\frac s2$

- 树表的查找:

    - 二叉排序树:又称二叉查找树.

    - 定义:

        - 若它的左子树不空,则左子树上所有节点的值均小于它的根节点的值.
        - 若它的右子树不空,则右子树上所有节点的值均大于它的根节点的值.
        - 它的左右子树也分别是二叉排序树.

    - 代码:

        ```c++
        /*
        * 二叉搜索树
        */
        #include<bits/stdc++.h>
        #define MAX_SIZE 100
        using namespace std;
        
        typedef struct BTNode {
        	int data;
        	bool flag;
        	BTNode* left;
        	BTNode* right;
        }BTNode, * BTree;
        
        BTree find(BTree BST, int e) {
        	if (!BST) {
        		return NULL;
        	}
        	if (e > BST->data) {
        		return find(BST->right, e);
        	}
        	else if (e < BST->data) {
        		return find(BST->left, e);
        	}
        	else  return BST;
        }
        BTree find2(BTree BST, int e) {
        	while (BST) {
        		if (e > BST->data) {
        			BST = find(BST->right, e);
        		}
        		else if (e < BST->data) {
        			BST = find(BST->left, e);
        		}
        		else return BST;
        	}
        	return NULL;
        }
        BTree findMin(BTree BST) {
        	if (!BST) {
        		return NULL;
        	}
        	/*else if (!BST->left) {
        		return BST;
        	}
        	else {
        		return findMin(BST->left);
        	}*/
        	else {
        		while (BST->left) {
        			BST = BST->left;
        		}
        	}
        	return BST;
        }
        BTree findMax(BTree BST) {
        	if (!BST) {
        		return NULL;
        	}
        	else {
        		while (BST->right) {
        			BST = BST->right;
        		}
        	}
        	return BST;
        }
        BTree insert(BTree& BST, int e) {
        	if (!BST) {
        		BST = new BTNode;
        		BST->data = e;
        		BST->left = BST->right = NULL;
        	}
        	else {
        		if (e < BST->data) {
        			BST->left = insert(BST->left, e);
        		}
        		else if (e > BST->data) {
        			BST->right = insert(BST->right, e);
        		}
        	}
        	return BST;
        }
        void SequenceTra(BTree BST) {
        	if (!BST)return;
        	queue<BTree> Q;
        	BTree T = BST;
        	Q.push(T);
        	while (!Q.empty()) {
        		T = Q.front();
        		Q.pop();
        		cout << T->data << "\t";
        		if (T->left) Q.push(T->left);
        		if (T->right) Q.push(T->right);
        	}
        	cout << endl;
        }
        void doubleTra(BTree BT) {
        	if (!BT) {
        		return;
        	}
        	else if (!BT->right && !BT->left) {
        		cout << BT->data;
        	}
        	else {
        		cout << BT->data;
        		doubleTra(BT->left);
        		cout << BT->data;
        		doubleTra(BT->right);
        	}
        }
        BTree deleteNode(BTree& BST, int e) {
        	BTree tmp;
        	if (!BST) {
        		cout << "要删除的元素未找到!\n";
        	}
        	else if (e < BST->data) {
        		BST->left = deleteNode(BST->left, e);
        	}
        	else if (e > BST->data) {
        		BST->right = deleteNode(BST->right, e);
        	}
        	else {
        		if (BST->right && BST->left) {
        			tmp = findMin(BST->right);
        			BST->data = tmp->data;
        			BST->right = deleteNode(BST->right, BST->data);
        		}
        		else {
        			tmp = BST;
        			if (!BST->left) {
        				BST = BST->right;
        			}
        			else if (!BST->right) {
        				BST = BST->left;
        			}
        			free(tmp);
        		}
        	}return BST;
        }
        void longestPath(BTree BT) {
        	BTree i[MAX_SIZE], s[MAX_SIZE], p = BT;
        	int j, tag[MAX_SIZE], top = 0, longest = 0;
        	while (p || top > 0) {
        		while (p) {
        			s[++top] = p;
        			tag[top] = 0;
        			p = p->left;
        		}
        		if (tag[top] == 1) {
        			if (!s[top]->left && !s[top]->right) {
        				if (top > longest) {
        					for (j = 1; j <= top; j++) {
        						i[j] = s[j];
        					}
        					longest = top;
        					top--;
        				}
        				else if (top > 0) {
        					tag[top] = 1;
        					p = s[top]->right;
        				}
        			}
        		}
        	}
        	cout << longest << endl;
        	for (j = 0; j < longest; j++) {
        		cout << i[j]->data << endl;
        	}
        }
        void postTraversal(BTree BT) {
        	if (BT) {
        		postTraversal(BT->left);
        		postTraversal(BT->right);
        		cout << BT->data;
        	}
        }
        ```

    - 平衡二叉树:

- 散列表的查找:

    - 基本概念:
        - 散列函数和散列地址:在记录的存储位置p和其关键字key之间,建立一个确定的对应关系H,使p=H(key),称这个对应关系H为散列函数,p为散列地址.
        - 散列表:一个有限连续的地址空间,用以存储按散列函数计算得到相应散列地址的数据记录.
        - 冲突和同义词:对不同关键词可能得到同一个散列地址,即key~1~$\neq$key~2~,而H(key~1~)=H(key~2~),这种现象称为冲突.具有相同函数值的关键字对该散列函数来说称作是同义词.

    - 散列函数构造方法:

        - 考虑因素:
            - 散列表的长度;
            - 关键字的长度;
            - 关键字的分布情况;
            - 计算散列函数所需时间;
            - 记录的查找长度;
        - 应遵循的原则:
            - 函数计算要简单,每一关键字只能有一个散列地址与之对应.
            - 函数的值域需要在表长范围内,计算出的散列地址的分布应均匀,尽可能减少冲突.
        - 方法:
            - 数字分析法.
            - 平方取中法.
            - 折叠法.
            - 除留余数法.

    - 处理冲突的方法:

        - 开放地址法:把记录都存储在散列表数组里,当某一记录关键字key的初始散列地址H~0~=H(key)发生冲突时,以H~0~为基础,采取合适方法计算得到另一个地址H~1~,如果H~1~仍然发生冲突,以H~1~为基础在求下一个地址,依此类推,直至H~k~不发生冲突为止.通常把寻找下一个空位的过程称为探测,上述方法可以用如下公式表示:
            $$
            H_i=(H(key)+d_i)\%m \qquad i=1,2,3,\dots,k\;(k\leq m-1)
            $$
            

            其中H(key)为散列函数,m为散列表长,d~i~为增量序列.根据d~i~的不同通常分为下列三种推测方法:

            - 线性探测法:
                - d~i~=1,2,3,...,m-1;
            - 二次探测法:
                - d~i~=1^2^,-1^2^,2^2^,-2^2^,...,k^2^,-k^2^;(k$\leq \frac m2$)
            - 伪随机数列:
                - d~i~=伪随机数列

        - 链地址法:把具有相同散列地址的记录放在同一个单链表里,称为同义词链表.有m个散列地址就有m个单链表,同时用数组HT[0...m-1]存放各个链表的头指针.

    - 散列表的查找:

        - 散列表的装填因子:$\alpha=\frac{表中填入的记录数}{散列表的长度}$
        - 散列表的平均查找长度是$\alpha$的函数
        - 查找失败的2种情况:
            - 单元为空.
            - 按处理冲突的方法探测一遍后仍然未找到.假设散列函数的取值个数为r,则0到r-1相当于r个查找失败的入口,从每个入口进入后,直到确定查找失败为止,其关键字的比较次数就是与该入口对应的查找失败的查找长度.

        - 平均查找长度:
            - $ASL_{succ}=\frac 1n\sum_{i=1}^nC_i$    n为散列表中的记录个数,C~i~为查找第i个记录成功所需次数.
            - $ASL_{unsucc}=\frac 1r\sum_{i=1}^rC_i$   r为散列函数的取值个数,C~i~为查找第i个记录失败所需次数.

## 八	排序

### 插入排序

#### 直接插入排序

-  将一条记录插入到已排好序的有序表中.

- 时间复杂度:O(n^2^) 稳定排序

 ```c++
    //插入排序
    void insertSort(int list[], int N) {
    	int temp, i, j;
    	for (i = 1; i < N; i++) {
    		//要插入的数
    		temp = list[i];
    		//给要插入的数腾出空
    		for (j = i; j > 0 && temp < list[j - 1]; j--) {
    			list[j] = list[j - 1];
    		}
    		//插入
    		list[j] = temp;
    	}
    }
 ```

#### 折半插入排序

- 将直接插入排序中的顺序查找变为折半查找.

- 时间复杂度:O(n^2^) 稳定排序

    ```c++
    void insertBinSort(int list[], int N) {
    	for (int i = 1; i < N; i++) {
		int temp = list[i];
    		int low = 1;
    		int high = i - 1;
    		int j = i - 1;
    		while (low <= high) {
    			int mid = (low + high) / 2;
    			if (temp < list[mid]) {
    				high = mid - 1;
    			}
    			else {
    				low = mid + 1;
    			}
    		}
    		for (; j >= high + 1; j--) {
    			list[j + 1] = list[j];
    		}
    		list[j] = temp;
    	}
    }
    ```
    
    

#### 希尔排序

- 定义增量序列D~k~<D~k-1~<...<D~1~ = 1;
- 对每个D~k~进行"D~K~-间隔"排序(k=M,M-1,...,1)
    -  对D~K~-间隔有序的序列进行D~K-1~-间隔排序后序列仍然是D~K~-间隔有序的.
- 增量元素不互质,则小增量可能根本不起作用.

- 原始希尔排序: D~M~ =N/2(向下取整),D~M-1~=D~M~/2

    - 最坏情况: T=θ(N^2^)
    - 最好情况: T=O(N)
    - 不稳定

 ``` c++
    //希尔排序
    void shellSort(int list[], int N) {
    	//希尔增量序列
    	for (int D = N / 2; D > 0; D /= 2) {
    		//以D为间隔的插入排序
    		for (int j, i = D; i < N; i++) {
    			int temp = list[D];
    			for (j = i; j >= D && list[j - D] > temp; j -= D) {
    				list[j] = list[j - D];
    			}
    			list[j] = temp;
    		}
    	}
    }
 ```

- Hibbard增量序列

    - D~K~=2^k^-1
    - 最坏情况:T=θ(N^3/2^)
    - 猜想: T~avg~=O(N^5/4^)

- Sedgewick增量序列

    - {1,5,9,41,109,...}

- 9 * 4^i^ - 9 * 2^i^ + 1 或 4^i^ - 3 * 2^i^ + 1

- 猜想:

    T~avg~=O(N^7/6^)

    T~worst~=O(N^4/3^)

### 交换排序

#### 冒泡排序

- 两两比较相邻的关键字,如果发生逆序,则进行交换,从而使关键字小(大)的记录如气泡般向上漂浮.

- 算法时间复杂度:O(n^2^) 稳定排序

    ```C++
    //冒泡排序
    void bubbleSort(int list[],int N){
        for(int i = N-1;i>=0;i--){
            int flag=0;
            for(int j=0;j<i;j++){
                if(list[j]>list[j+1]){
                    swap(list,j,j+1);
                    flag++;
                }
            }
            if(!flag){
                return;
            }
        }
    }
    ```

#### 快速排序

- 由冒泡排序改编而来,通过交换不相邻的2个元素消除多个逆序.

- 时间复杂度O(nlog~2~n) 不稳定

    ```c++
    int median(int list[], int low, int high) {
    	int mid = (low + high) / 2;
    	//使得low<mid<high
    	if (list[low] > list[mid]) {
    		swap(list, low, mid);
    	}
    	if (list[low] > list[high]) {
    		swap(list, low, high);
    	}
    	if (list[mid] > list[high]) {
    		swap(list, mid, high);
    	}
    	swap(list, mid, high - 1);
    	return list[high - 1];
    }
    void quickSort(int list[], int low, int high) {
    	int key, l, h;
    	key = median(list, low, high);
    	l = low, h = high - 1;
    	while (true) {
    		while (list[++l] < key);
    		while (list[--h] > key);
    		if (l < h) {
    			swap(list, l, h);
    		}
    		else {
    			break;
    		}
    	}
    	swap(list, l, h - 1);
    	quickSort(list, low, l - 1);
    	quickSort(list, l + 1, high);
    }
    void quickSort(int list[], int N) {
    	quickSort(list, 0, N - 1);
    }
    ```

    

### 选择排序

#### 简单选择排序

- 通过N-1次循环每次将未排序中最小的放在下标最前面

- 时间复杂度:O(n^2^) 稳定

    ``` c++
    //选择排序
    void selectSort(int list[],int N){
        for(int i=0;i<N-1;i++){
            for(int j=i+1;j<N;j++){
                if(list[i]>list[j]){
                    swap(list,i,j);
                }
            }
        }
    }
    ```

### 堆排序

- 利用最大堆的的根最大原理将数组先建成最大堆,再每次将最大堆的根节点和未排序序列最后一个交换.

- 时间复杂度:O(nlog~2~n)不稳定

    ```c++
    //下滤建堆
    void percDown(int list[], int p, int num) {
    	/*下滤:将以list[p]为根的子堆调整为最大堆*/
    	int parent, kid;
    	int temp;
    	temp = list[p];
    	for (parent = p; parent * 2 + 1 < num; parent = kid) {
    		/*为temp找到一个合适的位置,用parent指向这个位置*/
    		kid = parent * 2 + 1;
    		if (kid != num - 1 && list[kid] < list[kid + 1]) {
    			kid++;							// 令kid指向parent的左右元素中较大的一个
    		}
    		if (temp >= list[kid]) {		// 位置合适,跳出循环
    			break;
    		}
    		else {								// parent移动到下一层
    			list[parent] = list[kid];
    		}
    	}
    	list[parent] = temp;				// 将temp放到这个位置
    }
    //堆排序
    void heapSort(int list[], int N) {
    	for (int i = N / 2 - 1; i >= 0; i--) {
    		percDown(list, i, N);
    	}
    	for (int i = N - 1; i >= 0; i--) {
    		swap(list, 0, i);
    		percDown(list, 0, i);
    	}
    }
    ```

### 归并排序

#### 2-路归并排序

- 将初始数组看作N个有序子序列,再两两归并,如此重复直到得到一个有序序列.

- 时间复杂度:O(nlog~2~n)稳定

    ```c++
    
    ```

### 基数排序

- 稳定